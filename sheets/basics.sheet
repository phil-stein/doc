
modifiers:

#
|unsigned|type|signed|signdness|
    unsigned integer type variables can hold numbers 2x as big 
    as their signed equivalent, but can't hold negative numbers
    ! unsigned number going negative causes overflow
    example: 
      unsigned long long = 10;
      unsigned int       = 10;
      unsigned short     = 10;
      unsigned char      = 10;

      unsigned = 10;  // same as unsigned int 
#
|const|type|constant|
    variables marked const cant be modified during runtime
    can be applied to all types and structs
    ~ using const vars can speed up the program
    ~ using const can also prevent you from 
    ~ accidentally changing a value you shouln't
    example:
      const int c = 10;
      int a = c * 2;    // legal
      c = a * 2;        // illegal
#

data structures:

#
|array|data|type|
    arrays hold multiple variables 
    of the same type in direct succesion in memory
    arrays can be formed out of all variable types and structs
    ~ syntax: type var_name[]
    ~ first element in an array has index 0: array[0]
    example:
      int a[10];  // array of size 10 with undefined content
      int b[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
      printf("%d", b[3]); // access third element in b
        -> 3
#
|struct|structure|data|type|
    structs hold variables like an [array], but
    they can hold different types
    ~ [typedef]
    example:
      // definition
      struct data_t { int a; float b; }
      struct data_t var = { .a = 10, .b = 0.1f };
      int a = var.a;      // access variable in struct
      struct data_t* ptr = &var;
      float b = ptr->b;   // access variable in struct-pointer
#
|typedef|typedef|syntax|
    add a second name for a symbol
    example:
      // types
      typedef unsigned char u8;
      u8 a = 10;
      // enums
      enum a { A };
      typedef enum { A }b;

      enum a var_a = A;
      b      var_b = A;
      // structs
      struct a { int a; };
      typedef struct { int a; }b;

      struct a var_a = { .a = 0 };
      b        var_t = { .a = 0 };
#

actual types:

#
|void|type|
    used in functions with no return
    void* can point to anything
    ! void* doesn't give any information
    ! about the size/type of the value
    example: 
      void  func() {}
      void* ptr = &var;
#
|bool|boolean|type|
    either true or false
    true: 1, false: 0
    8 bit wide
    ! size of types varies, use sizeof() to test
    ! not included in all versions of c
    ~ include "stdbool.h"
    ~ or [define]/[typedef] bool, true, false
    example:
      bool a = true;
      a = false;
      a = 1;
      a = 0;
      if (a)  {...}
      if (!a) {...} // true->false, false->true
#
|char|type|
    char is a whole number
    signed by default
    8 bit wide
    ! size of types varies, use sizeof() to test
    ~ can use [unsigned] modifier
    example: 
      char  func() {}
      char  val = 10;
      char  val = 'A';
      char* ptr = &val;
#
|short|type|
    short is a whole number
    signed by default
    16 bit wide
    ! size of types varies, use sizeof() to test
    ~ can use [unsigned] modifier
    example: 
      short  func() {}
      short  val = 10;
      short* ptr = &val;
#
|int|type|
    int is a whole number
    signed by default
    abrev. for integer 
    32 bit wide
    ! size of types varies, use sizeof() to test
    ~ can use [unsigned] modifier
    example: 
      int  func() {}
      int  val = 10;
      int* ptr = &val;
#
|long|type|
    long is a whole number
    signed by default
    abrev. for integer 
    32 bit wide
    same as [int]
    ! size of types varies, use sizeof() to test
    ~ can use [unsigned] modifier
    example: 
      long  func() {}
      long  val = 10;
      long* ptr = &val;
#
|long-long|long|type|
    long long is a whole number
    signed by default
    abrev. for integer 
    64 bit wide
    ! size of types varies, use sizeof() to test
    ~ can use [unsigned] modifier
    example: 
      long long  func() {}
      long long  val = 10;
      long long* ptr = &val;
#
|float|type|
    float is a decimal number
    32 bit wide
    ! size of types varies, use sizeof() to test
    ~ literals end in 'f': '1.2f'
    example: 
      float  func() {}
      float  val = 12.345f;
      float* ptr = &val;
#
#
|double|type|
    double is a decimal number
    64 bit wide
    ! size of types varies, use sizeof() to test
    ~ unlike [float] literals dont end in 'f'
    example: 
      double  func() {}
      double  val = 12.345;
      double* ptr = &val;
#

non-standard:

#
|size_t|type|
    unsigned integer, defined in most standard header files
    32 bit wide when compiling 32bit, unsigned int
    64 bit wide when compiling 64bit, unsigned long long
    ! size of types varies, use sizeof() to test
    ~ no different from using an unsigned int directly
    ~ just for clarification of intent, i.e. loops, arrays, etc.
    ~ many standard headers use size_t when numbers cant be neg.
    example: 
      size_t size = sizeof(float);
#
#
|NULL|null|pointer|
    pointer of value 0, defined in most standard header files
    ! trying to acces a null pointer causes a crash
    ~ NULL is (void*)0
    example: 
     \#ifndef NULL
      \#define NULL (void*)0
     \#endif
     int* ptr = NULL;
     if (ptr \!= NULL) { free(ptr); }
     if (ptr)  { printf("ptr = not null"); }
     if (\!ptr) { printf("ptr = null"); }
#

@TODO: uint_8, etc..., but maybe add them in the sheet for the header that defines them ?

@TODO: 
#
|idk_what_these_are_called|comparison|basics|
  // @TODO: 
  ...
  example:
    a == b -> equal 
    a \!= b -> not equal
    a <  b -> less than
    a <= b -> less than or equal
    a >  b -> greater than
    a >= b -> greater than or equal
#
|idk_what_these_are_called|boolean|basics|
  // @TODO: 
  ...
  example:
    a && b -> both are true
    a || b -> a or b is true
#
|idk|bitwise_operator|basics|
  // @TODO: 
  bit shift
  <<
  >>
  bit wise or & and
  |
  &
#

@TODO:
#
|bit_flag|flag|bitwise_operator|basics|
  set and check certain bits in a number
  make number with bit a set

  ~ uses \|bitwise_operator\|

  example:
  
  make a number with specific bit set:
    1 << 0 0001
    1 << 1 0010
    1 << 2 0100
    1 << 3 1000
    aka. 1<<a == 2^a, 1, 2, 4, 8, ...
  combine numbers with specific bits set:
    unsigned int a = 1 << 0;  // 0001 
    unsigned int b = 1 << 3;  // 1000
    unsigned int c = a \| b;   // 1001
  check if bit is set:
    unsigned int a = 1 << 0;  // 0001 
    unsigned int b = 1 << 3;  // 1000   
    unsigned int c = a \| b;   // 1001
    bool d = a & b;           // false
    bool e = a & c;           // true, 0001 in common
  set specific bit 0:
    unsigned int a = 1 << 0 \| 1 << 3;  // 1001
    a = a &= \~(1 << 0);                // 1000

  macros:
    \#define FLAG(a)            (1 << (a))
    \#define HAS_FLAG(a, b)     ((a) & (b))
    \#define FLAG_COMBINE(a, b) ((a) \| (b))
    \#define REMOVE_FLAG(a, b)  ((a) &= ~(b))

  enums:
    enum example_flag
    {
      HAS_A = FLAG(0),
      HAS_B = FLAG(1),
      HAS_C = FLAG(2)
    };
    example_flag a = HAS_A \| HAS_B \| HAS_C;
    REMOVE_FLAG(a, HAS_B);
    if (HAS_FLAG(a, HAS_A)) { printf("has a");}
    if (HAS_FLAG(a, HAS_B)) { printf("has b");}
    if (HAS_FLAG(a, HAS_C)) { printf("has c");}
      -> has a
      -> has b
#

macros:

#
|stringify|
|preprocessor|macro|basics|
  and \\# to macro arg to stringify it
  example:
    \#define TO_STR(arg)  (\\#arg)
    int var = 0;
    printf("%s: %d\n", TO_STR(var), var);
      -> var: 0
    \#define P_INT(a) printf("%s: %d\n", \\#a, a)
    P_INT(var);
      -> var: 0
#
|__FILE__|__LINE__|
|file|line|preprocessor|macro|basics|
  __FILE__ is a marco that gets set to the 
  current file name during compilation
  __LINE__ is a marco that gets set to the 
  current line during compilation

  example:
    \#define PRINT_LOCATION() printf("file: \"%s\", line: %d\n", __FILE__, __LINE__)
    file_a.c:
    [83] PRINT_LOCATION();
      -> file: "file_a.c", line: 83
    file_b.c:
    [10] PRINT_LOCATION();
      -> file: "file_b.c", line: 10
#
|define|
|preprocessor|macro|basics|
    the define preprocessor registeres a piece of code under a name
    ~ use '\' to make multiline macros, no whitespace after '\'
    ~ wrapping args in parenthesis makes it safer 
    example:
      \#define NAME 34 * 67
      \#define ADD(a, b) ((a) + (b))
      \#define WARNING()      \
        printf("[!!!]");      \
        printf(" warning\n")

      printf("%d\n", NAME);
      printf("%d\n", ADD(30, 70));
      WARNING();
        -> 2278 
        -> 100
        -> "[!!!] warning"
#
|undef|
|undefine|preprocessor|macro|basics|
  // @TODO:
#
|if|
|endif|preprocessor|macro|basics|
  check a condition at compile time and include a piece of code or not
  ! has to be terminated with one of \#endif, \#else or \#elif
  
  example:
    \#if 0 == 0
    printf("0 == 0");
    \#endif
    \#if 0 == 1
    printf("0 == 1");
    \#endif
      -> 0 == 0
#
|else|
|endif|preprocessor|macro|basics|
  used with the \\#if, \\#elif, \\#ifdef preprocessors
  
  example:
    \#if 0 == 0
    printf("0 == 0");
    \#else
    printf("0 != 0");
    \#endif
      -> 0 == 0
#
|elif|
|else|endif|preprocessor|macro|basics|
  used with the \\#if, \\#else, \\#ifdef preprocessors
  
  example:
    \#if 0 == 0
    printf("0 == 0");
    \#elif 0 == 1
    printf("0 == 1");
    \#endif
      -> 0 == 0
#
|ifdef|
|endif|preprocessor|macro|basics|
  // @TODO:
#
|ifndef|
|endif|preprocessor|macro|basics|
  // @TODO:
#
|if|
|flow_control|basics|
  execute a piece of code based on a condition

  example:
    if (0 == 0)  { printf("0 == 0"); }
    if (true)    { printf("true"); }
    if (false)   { printf("false"); }
    bool boolean = true;
    if (boolean) { printf("boolean"); }
    boolean = false;
    if (boolean) { printf("boolean"); }
      -> 0 == 0
      -> true
      -> boolean
#
|else|
|flow_control|basics|
  // @TODO:
#
|else_if|
|else|if|flow_control|basics|
  // @TODO:
#
|while|
|flow_control|loop|basics|
  // @TODO:
#
|do_while|
|while|flow_control|basics|
  // @TODO:
#
|for|
|flow_control|loop|basics|
  // @TODO:
#

compiler stuff, should prob get its own sheet:

#
|c-version|c|version|c89|c99|c11|c18|compiler|macro|
    c was originally made in 1972 by Dennis Ritchie, 
    so theres been a lot of versions since then
    if you want to check which version you are
    currently compiling in use the macros shown below

    setting a specific c version to use 
    depends on the compiler see below

    example:
      // print version
      if (__STDC_VERSION__ >=  201710L)       
      { printf("-- using c18 --\n"); }            
      else if (__STDC_VERSION__ >= 201112L)   
      { printf("-- using c11 --\n"); }            
      else if (__STDC_VERSION__ >= 199901L)   
      { printf("-- using c99 --\n"); }            
      else                                    
      { printf("-- using c89/c90 --\n"); }
      
      // set version in compiler
      // in makefile / directly in terminal
      
      gcc -std=c90  // c89 / c90
      gcc -std=c99  // c99
      gcc -std=c11  // c11
      gcc -std=c17  // c17 / 18
      // c89 and c90 is the same version
      // in gcc c99 implemnts corrertions of the early 2000s versions
      // in gcc c11 and c17 only differ in the value '__STDC_VERSION__'

      clang -std=c89 -std=c90   // c89 / c90
      clang -std=gnu89          // c89 with gnu extensins
      clang -std=c99
      clang -std=gnu99          // c99 with gnu extensins
      clang -std=c11
      clang -std=gnu11          // c11 with gnu extensins
      clang -std=c17
      clang -std=gnu17          // c17 with gnu extensins

      // msvc is a windows specific compiler made by
      // microsoft for Visial Studio, etc.
      // could not find older versions supported by msvc
      // use '/' or '-' to start a command  
      msvc /std:c11 -std:c11
      msvc /std:c17 -std:c17

      ?< gcc: https://gcc.gnu.org/onlinedocs/gcc/Standards.html >?
      ?< clang: https://clang.llvm.org/docs/CommandGuide/clang.html >?
      ?< msvc: https://docs.microsoft.com/en-us/cpp/build/reference/compiler-options-listed-by-category?view=msvc-170 >?
      ?<c: https://en.wikipedia.org/wiki/C_(programming_language) >?           
#



