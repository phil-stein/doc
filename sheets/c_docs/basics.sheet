
modifiers:

#
|unsigned|type|signed|signdness|
    unsigned integer type variables can hold numbers 2x as big 
    as their signed equivalent, but can't hold negative numbers
    ! unsigned number going negative causes overflow
    example: 
      unsigned long long = 10;
      unsigned int       = 10;
      unsigned short     = 10;
      unsigned char      = 10;

      unsigned = 10;  // same as unsigned int 
#
|const|type|constant|
    variables marked const cant be modified during runtime
    can be applied to all types and structs
    ~ using const vars can speed up the program
    ~ using const can also prevent you from 
    ~ accidentally changing a value you shouln't
    example:
      const int c = 10;
      int a = c * 2;    // legal
      c = a * 2;        // illegal
#

data structures:

#
|array|data|type|
    arrays hold multiple variables 
    of the same type in direct succesion in memory
    arrays can be formed out of all variable types and structs
    ~ syntax: type var_name[]
    ~ first element in an array has index 0: array[0]
    example:
      int a[10];  // array of size 10 with undefined content
      int b[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
      printf("%d", b[3]); // access third element in b
        -> 3
#
|struct|structure|data|type|
    structs hold variables like an [array], but
    they can hold different types
    ~ [typedef]
    example:
      // definition
      struct data_t { int a; float b; }
      struct data_t var = { .a = 10, .b = 0.1f };
      int a = var.a;      // access variable in struct
      struct data_t* ptr = &var;
      float b = ptr->b;   // access variable in struct-pointer
#
|typedef|typedef|syntax|
    add a second name for a symbol
    example:
      // types
      typedef unsigned char u8;
      u8 a = 10;
      // enums
      enum a { A };
      typedef enum { A }b;

      enum a var_a = A;
      b      var_b = A;
      // structs
      struct a { int a; };
      typedef struct { int a; }b;

      struct a var_a = { .a = 0 };
      b        var_t = { .a = 0 };
#

actual types:

#
|void|type|
    used in functions with no return
    void* can point to anything
    ! void* doesn't give any information
    ! about the size/type of the value
    example: 
      void  func() {}
      void* ptr = &var;
#
|bool|boolean|type|
    either true or false
    true: 1, false: 0
    8 bit wide
    ! size of types varies, use sizeof() to test
    ! not included in all versions of c
    ~ include "stdbool.h"
    ~ or [define]/[typedef] bool, true, false
    example:
      bool a = true;
      a = false;
      a = 1;
      a = 0;
      if (a)  {...}
      if (!a) {...} // true->false, false->true
#
|char|type|
    char is a whole number
    signed by default
    8 bit wide
    ! size of types varies, use sizeof() to test
    ~ can use [unsigned] modifier
    example: 
      char  func() {}
      char  val = 10;
      char  val = 'A';
      char* ptr = &val;
#
|short|type|
    short is a whole number
    signed by default
    16 bit wide
    ! size of types varies, use sizeof() to test
    ~ can use [unsigned] modifier
    example: 
      short  func() {}
      short  val = 10;
      short* ptr = &val;
#
|int|type|
    int is a whole number
    signed by default
    abrev. for integer 
    32 bit wide
    ! size of types varies, use sizeof() to test
    ~ can use [unsigned] modifier
    example: 
      int  func() {}
      int  val = 10;
      int* ptr = &val;
#
|long|type|
    long is a whole number
    signed by default
    abrev. for integer 
    32 bit wide
    same as [int]
    ! size of types varies, use sizeof() to test
    ~ can use [unsigned] modifier
    example: 
      long  func() {}
      long  val = 10;
      long* ptr = &val;
#
|long-long|long|type|
    long long is a whole number
    signed by default
    abrev. for integer 
    64 bit wide
    ! size of types varies, use sizeof() to test
    ~ can use [unsigned] modifier
    example: 
      long long  func() {}
      long long  val = 10;
      long long* ptr = &val;
#
|float|type|
    float is a decimal number
    32 bit wide
    ! size of types varies, use sizeof() to test
    ~ literals end in 'f': '1.2f'
    example: 
      float  func() {}
      float  val = 12.345f;
      float* ptr = &val;
#
#
|double|type|
    double is a decimal number
    64 bit wide
    ! size of types varies, use sizeof() to test
    ~ unlike [float] literals dont end in 'f'
    example: 
      double  func() {}
      double  val = 12.345;
      double* ptr = &val;
#

non-standard:

#
|size_t|type|
    unsigned integer, defined in most standard header files
    32 bit wide when compiling 32bit, unsigned int
    64 bit wide when compiling 64bit, unsigned long long
    ! size of types varies, use sizeof() to test
    ~ no different from using an unsigned int directly
    ~ just for clarification of intent, i.e. loops, arrays, etc.
    ~ many standard headers use size_t when numbers cant be neg.
    example: 
      size_t size = sizeof(float);
#
#
|NULL|null|pointer|
    pointer of value 0, defined in most standard header files
    ! trying to acces a null pointer causes a crash
    ~ NULL is (void*)0
    example: 
     \#ifndef NULL
      \#define NULL (void*)0
     \#endif
     int* ptr = NULL;
     if (ptr \!= NULL) { free(ptr); }
     if (ptr)  { printf("ptr = not null"); }
     if (\!ptr) { printf("ptr = null"); }
#

#
|!|invert|not|
|operator|boolean_operators|boolean|basics|
  \! inverts any boolean value

  example:
    bool a = true;
    bool b = \!a;    // b is now false
    a = \!a;         // a is now false
    a = \!a;         // a is now true
    int c = 0;
    c = \!c;         // c is now 1
    
    if (\!a) 
    { printf("a didnt change value, but was evaluated as false"); }
    
    a = true; b = true;
    if (\!(a && b)) { printf("wont execute"); }

    bool func() { return true; }

    if ( func()) { printf("func()"); }
    if (\!func()) { printf("!func()"); }
    
    // a is true so this evals. as \!(true) -> false
    bool d = \!(a \? true : false); 

    -> func()
#

@TODO: 
#
|idk_what_these_are_called|comparison|basics|
|operator|boolean_operators|boolean|basics|
|==|!=|<|<=|>|>=|&&|
  // @TODO: 
  ...
  example:
    a == b -> equal 
    a \!= b -> not equal
    a <  b -> less than
    a <= b -> less than or equal
    a >  b -> greater than
    a >= b -> greater than or equal
    
    a && b -> both are true
    a \|\| b -> a or b is true
#
|operator|bitwise_operator|basics|
|<<|>>|&|
  bit shift
    <<
    >>
  bit wise or, and & not
    \|
    &
    \~
  example:
    a = 0b001; // a is now 001
    a >> 1;    // a is now 010
    a << 1;    // a is now 001
#
|bit_flag|flag|bitwise_operator|basics|
  set and check certain bits in a number
  make number with bit a set

  ~ uses \|bitwise_operator\|

  example:
  
  make a number with specific bit set:
    1 << 0 0001
    1 << 1 0010
    1 << 2 0100
    1 << 3 1000
    aka. 1<<a == 2^a, 1, 2, 4, 8, ...
  combine numbers with specific bits set:
    unsigned int a = 1 << 0;  // 0001 
    unsigned int b = 1 << 3;  // 1000
    unsigned int c = a \| b;   // 1001
  check if bit is set:
    unsigned int a = 1 << 0;  // 0001 
    unsigned int b = 1 << 3;  // 1000   
    unsigned int c = a \| b;   // 1001
    bool d = a & b;           // false
    bool e = a & c;           // true, 0001 in common
  set specific bit 0:
    unsigned int a = 1 << 0 \| 1 << 3;  // 1001
    a = a &= \~(1 << 0);                // 1000

  macros:
    \#define FLAG(a)            (1 << (a))
    \#define HAS_FLAG(a, b)     ((a) & (b))
    \#define FLAG_COMBINE(a, b) ((a) \| (b))
    \#define REMOVE_FLAG(a, b)  ((a) &= ~(b))

  enums:
    enum example_flag
    {
      HAS_A = FLAG(0),
      HAS_B = FLAG(1),
      HAS_C = FLAG(2)
    };
    example_flag a = HAS_A \| HAS_B \| HAS_C;
    REMOVE_FLAG(a, HAS_B);
    if (HAS_FLAG(a, HAS_A)) { printf("has a");}
    if (HAS_FLAG(a, HAS_B)) { printf("has b");}
    if (HAS_FLAG(a, HAS_C)) { printf("has c");}
      -> has a
      -> has b
#

macros:

#
|stringify|
|preprocessor|macro|basics|
  and \\# to macro arg to stringify it
  example:
    \#define TO_STR(arg)  (\\#arg)
    int var = 0;
    printf("%s: %d\n", TO_STR(var), var);
      -> var: 0
    \#define P_INT(a) printf("%s: %d\n", \\#a, a)
    P_INT(var);
      -> var: 0
#
|__FILE__|__LINE__|
|file|line|preprocessor|macro|basics|
  __FILE__ is a marco that gets set to the 
  current file name during compilation
  __LINE__ is a marco that gets set to the 
  current line during compilation

  example:
    \#define PRINT_LOCATION() printf("file: \"%s\", line: %d\n", __FILE__, __LINE__)
    file_a.c:
    [83] PRINT_LOCATION();
      -> file: "file_a.c", line: 83
    file_b.c:
    [10] PRINT_LOCATION();
      -> file: "file_b.c", line: 10
#
|compiler|_MSC_VER|__MINGW64__|
|c++|__cplusplus|
|macro|preprocessor|basics|
  compiler defining macros
  ~ see \|c-version\| for checking/setting the c version
// @TODO: gcc, clang
  _MSC_VER:    msvc, microsofts c/c++ compiler
  __MINGW64__: 64 bit version of mingw

  __cplusplus: actually compiling c++ code
               c++ compilers can compile c
               but you need to define extern "C"
  example:
    in .h file
    \#ifdef __cplusplus
    extern "C" {
    \#endif
    void func();
    \#ifdef __cplusplus
    } // extern "C"
    \#endif
#
|_WIN32|_WIN64|__linux|__linux__|__APPLE__|__ANDROID__|
|windows|linux|apple|macos|android|operating_system|os|
|macro|preprocessor|basics|
  os specific macros

// @UNSURE: win32 just mean 32 bit application or os
  _WIN32:      is defined when on a windows 32 bit operating system
  _WIN64:      is defined when on a windows 64 bit operating system
  __linux
  __linux__:   is defined when on a linux operating system
  __APPLE__:   is defined when on a apple / macos operating system
  __ANDROID__: is defined when on a android operating system

  example:
    \#ifdef _WIN32
      printf("running on windows");
    \#elif  defined(__linux__)
      printf("running on linux");
    \#endid
#
|__VA_ARGS__|
|variadic_arguments|variadic|preprocessor|macro|basics|
  the macro __VA_ARGS__ is used when creating variadic macros
  which means macros that variable amount of arguments
  it is the arguments themself, and should only directly be
  passed to a variadic function

  example:
    \#define PF(...)    printf(__VA_ARGS__)
    PF("hello\n");
    PF("int: %d\n", 12);
    PF("%s %s %s\n" "multiple", "args", "given");
    -> hello
    -> int: 12
    -> multiple args given
#
|defined|
|preprocessor|macro|basics|
  turns a macro into a suitable condition for \\#if, \\#elif

  example:
    \#define A
    \#if    defined(A)
      printf("A");
    \#elif  defined(B)
      printf("B");
    \#elif !defined(B)
      printf("not B");
    \#endif
    -> A
    -> not B
#
|define|
|preprocessor|macro|basics|
    the define preprocessor registeres 
    a piece of code under a name
    alternatively a macro can also just 
    be defined to check if its defined using \\#ifdef
    ~ use '\' to make multiline macros, no whitespace after '\'
    ~ wrapping args in parenthesis makes it safer 
    example:
      \#define HELLO
      \#define NAME   "karl"
      \#define NUMBER 34 * 67
      \#define ADD(a, b) ((a) + (b))
      \#define WARNING()      \
        printf("[!!!]");      \
        printf(" warning\n")

      printf("%s\n", NAME);
      printf("%d\n", NUMBER);
      printf("%d\n", ADD(30, 70));
      WARNING();
      \#ifdef HELLO
        printf("hello is defined\n");
      \#endif
        -> karl
        -> 2278 
        -> 100
        -> [!!!] warning
        -> hello is defined
#
|undef|
|undefine|preprocessor|macro|basics|
  the undef preprocessor undefines a previously defined macro
  example:
    \#define A
    \#ifdef A
      printf("A");
    \#endif
    \#undef A
    \#ifdef A
      printf("A again");
    \#endif
    -> A
#
|if|
|endif|preprocessor|macro|basics|
  check a condition at compile time and include a piece of code or not
  ! has to be terminated with one of \#endif, \#else or \#elif
  
  example:
    \#if 0 == 0
    printf("0 == 0");
    \#endif
    \#if 0 == 1
    printf("0 == 1");
    \#endif
      -> 0 == 0
#
|else|
|endif|preprocessor|macro|basics|
  used with the \\#if, \\#elif, \\#ifdef preprocessors
  
  example:
    \#if 0 == 0
    printf("0 == 0");
    \#else
    printf("0 != 0");
    \#endif
      -> 0 == 0
#
|elif|
|else|endif|preprocessor|macro|basics|
  used with the \\#if, \\#else, \\#ifdef preprocessors

  example:
    \#if 0 == 0
    printf("0 == 0");
    \#elif 0 == 1
    printf("0 == 1");
    \#endif
      -> 0 == 0
#
|ifdef|
|endif|preprocessor|macro|basics|
  the ifdef preprocessor ex/includes a part of code
  depending on if the given macro is defined

  example:
    \#ifdef A
      printf("A0");
    \#endif
    \#define A
    \#ifdef A
      printf("A1");
    \#endif
    -> A1
#
|ifndef|
|endif|preprocessor|macro|basics|
  the ifndef preprocessor ex/includes a part of code
  depending on if the given macro is not defined

  example:
    \#ifndef A
      printf("A0");
    \#endif
    \#define A
    \#ifndef A
      printf("A1");
    \#endif
    -> A0
#
|if|
|flow_control|basics|
  execute a piece of code based on a condition

  example:
    if (0 == 0)  { printf("0 == 0"); }
    if (true)    { printf("true"); }
    if (false)   { printf("false"); }
    bool boolean = true;
    if (boolean) { printf("boolean"); }
    boolean = false;
    if (boolean) { printf("boolean"); }
      -> 0 == 0
      -> true
      -> boolean
#
|else|else_if|
|flow_control|basics|
  after a if or else if statement this executes
  a block of code if the previous statement didnt
  else if executes the block of code under those 
  circumstances as well as checking the given condition

  example:
    if (0 == 0) { printf("0 if");   }
    else        { printf("0 else"); }
    
    if (0 == 1) { printf("1 if");   }
    else        { printf("1 else"); }

    if (0 == 1)    { printf("2 if");      }
    else if (0==0) { printf("2 else if"); }
    else           { printf("2 else");    }
    
    int c = 2;
    if (c == 0)      { printf("c == 0"); }
    else if (c == 1) { printf("c == 1"); }
    else if (c == 2) { printf("c == 2"); }
    else if (c == 3) { printf("c == 3"); }
    else             { printf("c == ?"); }
    -> 0 if
    -> 1 else
    -> 2 else if
    -> c == 2
#
|idk|
|flow_control|basics|
  single line statement evaluating to a value
  that works like a if / if else / else chain
  
  $GREEN$structure$$:
    condition ? if true : if false
    can be chained
    condition_a ? if true : condition_b ? if true : ...

  example:
    // eval to bool
    bool a = 0 == 0 ? true : false; // 0 is 0 so a is true
    if (a ? false : true) {}
    
    // eval to other value
    int num  = 3;
    int num2 = num == 0 ? 0 : num == 1 ? 1 : 
               num == 2 ? 2 : num == 3 : 3;    // num2 is also 3

    float speed = 10.0f;
    pow(2, speed > 8.0f ? 4 : 6);
#
|while|while_loop|
|flow_control|loop|basics|
|break|continue|
  repeatedly executes a block of code
  while the given condition is true
  ~ use the break command to exit the loop
  ~ use continue to skip the rest of the current loops run
  ~ and continue at the start of the lopo
  ! if the condition never turns false
  ! the program will be stuck in the loop

  example:
    // for loop using while loop
    int count = 10;
    while (count <= 0) { printf("%d, ", count); count--; }
    -> 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0,

    // search string text for '%'
    bool found = false;
    int  pos   = 0;
    while (found = false && pos < text_length)
    { if (text[pos] == '%') { found = true; } pos++; }
    if (found) { printf("found %% at %d\n", pos); }
    -> found % at XXX

    // infinite loop, with break
    int end = 222;
    int pos = 0;
    while (true)
    { 
      if (pos >= end) { break;} 
      pos++;
    }
    printf("pos: %d\n", pos);
    -> pos: 221

#
|do_while|do|while|do_while_loop|
|flow_control|basics|
  same as while loop, only that this loop executes the block
  once before checking the condition, assuring it always gets 
  executed least once
  see \|while\| for more explanation

  example:
    int a = 0;
    do
    {
      a++;
    }
    while (false);
    printf("a: %d\n", a);
    -> a: 1
#
|for|for_loop|
|flow_control|loop|basics|
  the for loop executes a block of code 
  as long as the middle condition is true
  it also initializes a local variable
  and allows you to execute a line of code 
  at the end of each loop
  this loop cant do anything the while loop cant do
  but its purpose is often easier to understand
  thanks to the for loops's structure
  ~ its common to call the for loops variable i
  ~ for iterator, j, k, follow if you have a nested loop

  $GREEN$structure$$:
    for (INITIALIZE_VAR; CONDITION; EXECUTES_AT_END_OF_LOOP)
    { BLOCK_OF_CODE }
    ~ equivalent to:
    INITIALIZE_VAR
    while (CONDITION)
    {
      BLOCK_OF_CODE
      EXECUTES_AT_END_OF_LOOP
    }
  example: 
    for (int i = 0; i < 10; ++i)
    { printf("%d, ", i); }
    -> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
    
    int arr[3] = { 4, 5, 6 };
    int arr_len = 3;
    for (int i = 0; i < arr_len; ++i)
    { printf("%d, ", arr[i]); }
    -> 4, 5, 6,
#

compiler stuff, should prob get its own sheet:

#
|c-version|c|version|c89|c99|c11|c18|compiler|macro|
    c was originally made in 1972 by Dennis Ritchie, 
    so theres been a lot of versions since then
    if you want to check which version you are
    currently compiling in use the macros shown below

    setting a specific c version to use 
    depends on the compiler see below

    example:
      // print version
      if (__STDC_VERSION__ >=  201710L)       
      { printf("-- using c18 --\n"); }            
      else if (__STDC_VERSION__ >= 201112L)   
      { printf("-- using c11 --\n"); }            
      else if (__STDC_VERSION__ >= 199901L)   
      { printf("-- using c99 --\n"); }            
      else                                    
      { printf("-- using c89/c90 --\n"); }
      
      // set version in compiler
      // in makefile / directly in terminal
      
      gcc -std=c90  // c89 / c90
      gcc -std=c99  // c99
      gcc -std=c11  // c11
      gcc -std=c17  // c17 / 18
      // c89 and c90 is the same version
      // in gcc c99 implemnts corrertions of the early 2000s versions
      // in gcc c11 and c17 only differ in the value '__STDC_VERSION__'

      clang -std=c89 -std=c90   // c89 / c90
      clang -std=gnu89          // c89 with gnu extensins
      clang -std=c99
      clang -std=gnu99          // c99 with gnu extensins
      clang -std=c11
      clang -std=gnu11          // c11 with gnu extensins
      clang -std=c17
      clang -std=gnu17          // c17 with gnu extensins

      // msvc is a windows specific compiler made by
      // microsoft for Visial Studio, etc.
      // could not find older versions supported by msvc
      // use '/' or '-' to start a command  
      msvc /std:c11 -std:c11
      msvc /std:c17 -std:c17

      ?< gcc: https://gcc.gnu.org/onlinedocs/gcc/Standards.html >?
      ?< clang: https://clang.llvm.org/docs/CommandGuide/clang.html >?
      ?< msvc: https://docs.microsoft.com/en-us/cpp/build/reference/compiler-options-listed-by-category?view=msvc-170 >?
      ?<c: https://en.wikipedia.org/wiki/C_(programming_language) >?           
#



