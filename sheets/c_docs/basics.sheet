
modifiers:

#
|unsigned|type|signed|signdness|
    unsigned integer type variables can hold numbers 2x as big 
    as their signed equivalent, but can't hold negative numbers
    ! unsigned number going negative causes overflow
    example: 
      unsigned long long = 10;
      unsigned int       = 10;
      unsigned short     = 10;
      unsigned char      = 10;

      unsigned = 10;  // same as unsigned int 
#
|const|type|constant|
    variables marked const cant be modified during runtime
    can be applied to all types and structs
    ~ using const vars can speed up the program
    ~ using const can also prevent you from 
    ~ accidentally changing a value you shouln't
    example:
      const int c = 10;
      int a = c * 2;    // legal
      c = a * 2;        // illegal
#

data structures:

#
|array|data|type|
    arrays hold multiple variables 
    of the same type in direct succesion in memory
    arrays can be formed out of all variable types and structs
    ~ syntax: type var_name[]
    ~ first element in an array has index 0: array[0]
    example:
      int a[10];  // array of size 10 with undefined content
      int b[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
      printf("%d", b[3]); // access third element in b
        -> 3
#
|struct|structure|data|type|
    structs hold variables like an [array], but
    they can hold different types
    ~ [typedef]
    example:
      // definition
      struct data_t { int a; float b; }
      struct data_t var = { .a = 10, .b = 0.1f };
      int a = var.a;      // access variable in struct
      struct data_t* ptr = &var;
      float b = ptr->b;   // access variable in struct-pointer
#
|union|data|type|
  unions are declared like structs, with multiple
  variables, but their size is only the size of the 
  biggest variable.
  meaning all variables in a union share the same memory

  example:
    union a
    {
      char   c; // size 1 byte
      short  s; // size 2 bytes
      int    i; // size 4 bytes
      double d; // size 8 bytes
    };
    printf("sizeof(a): %d", sizeof(a));
    -> sizeof(a): 8
    because d is the biggest variable at 8 bytes

    union b
    {
      unsigned int i;
      float f;
    };
    union b var;
    var.i = 10;
    var.f now has 10u as its value
    which prob. will not read as a proper float value
    and definitely not as 10.0f
#
|typedef|typedef|syntax|
    add a second name for a symbol
    example:
      // types
      typedef unsigned char u8;
      u8 a = 10;
      // enums
      enum a { A };
      typedef enum { A }b;

      enum a var_a = A;
      b      var_b = A;
      // structs
      struct a { int a; };
      typedef struct { int a; }b;

      struct a var_a = { .a = 0 };
      b        var_t = { .a = 0 };
#

actual types:

#
|void|type|
    used in functions with no return
    void* can point to anything
    ! void* doesn't give any information
    ! about the size/type of the value
    example: 
      void  func() {}
      void* ptr = &var;
#
|bool|boolean|type|
    either true or false
    true: 1, false: 0
    8 bit wide
    ! size of types varies, use sizeof() to test
    ! not included in all versions of c
    ~ include "stdbool.h"
    ~ or [define]/[typedef] bool, true, false
    example:
      bool a = true;
      a = false;
      a = 1;
      a = 0;
      if (a)  {...}
      if (!a) {...} // true->false, false->true
#
|char|type|
    char is a whole number
    signed by default
    8 bit wide
    ! size of types varies, use sizeof() to test
    ~ can use [unsigned] modifier
    example: 
      char  func() {}
      char  val = 10;
      char  val = 'A';
      char* ptr = &val;
#
|short|type|
    short is a whole number
    signed by default
    16 bit wide
    ! size of types varies, use sizeof() to test
    ~ can use [unsigned] modifier
    example: 
      short  func() {}
      short  val = 10;
      short* ptr = &val;
#
|int|type|
    int is a whole number
    signed by default
    abrev. for integer 
    32 bit wide
    ! size of types varies, use sizeof() to test
    ~ can use [unsigned] modifier
    example: 
      int  func() {}
      int  val = 10;
      int* ptr = &val;
#
|long|type|
    long is a whole number
    signed by default
    abrev. for integer 
    32 bit wide
    same as [int]
    ! size of types varies, use sizeof() to test
    ~ can use [unsigned] modifier
    example: 
      long  func() {}
      long  val = 10;
      long* ptr = &val;
#
|long-long|long|type|
    long long is a whole number
    signed by default
    abrev. for integer 
    64 bit wide
    ! size of types varies, use sizeof() to test
    ~ can use [unsigned] modifier
    example: 
      long long  func() {}
      long long  val = 10;
      long long* ptr = &val;
#
|float|type|
    float is a decimal number
    32 bit wide
    ! size of types varies, use sizeof() to test
    ~ literals end in 'f': '1.2f'
    example: 
      float  func() {}
      float  val = 12.345f;
      float* ptr = &val;
#
#
|double|type|
    double is a decimal number
    64 bit wide
    ! size of types varies, use sizeof() to test
    ~ unlike [float] literals dont end in 'f'
    example: 
      double  func() {}
      double  val = 12.345;
      double* ptr = &val;
#

#
|literal|literals|number|numbers|string|
  literals are values types directly into the code

  ~ multiline string, like mutliline macro, has to be directly 
  $~$  followed by newline char '\n', aka. nothing after \ char$$

  example:
    int i = 10;       // normal, decimal integer
    int i = 0b101     // base 2,  binary
    int i = 010;      // base 8,  octal
    int i = 0x1A;     // base 16, hexadecimal
    unsigned int       i = 10u; // unsigned decimal integer
    long long          i = 10l; // long decimal integer
    unsigned long long i = 10ul; // unsigned long decimal integer

    float  f = 10.5f;    // float literal
    float  f = 105E-1L;  // float literal, with exponent
    float  f = 105E-1;   // float literal, with exponent
    float  f = 105e-1L;  // float literal, with exponent
    float  f = 105e-1;   // float literal, with exponent
    double f = 10.5;     // double literal
    double f = 105E-1L;  // double literal, with exponent
    double f = 105E-1;   // double literal, with exponent
    double f = 105e-1L;  // double literal, with exponent
    double f = 105e-1;   // double literal, with exponent
    
    char   c = 'c';     // char literal
    char   c = '\n';    // char literal, escaped char
    char   c = 'u0040'; // char literal, unicode, this is @
    
    char*  s = "hello";  // string literal
    char*  s = "hello"",""world"; // acts as one string "hello, world"
    \#define STR "middle"
    char   s = "start "STR" end"  // acts as one string "start middle end"
    char*  s = "line01 \
                line02";  // multiline string literal
  
#

non-standard:

#
|size_t|type|
    unsigned integer, defined in most standard header files
    32 bit wide when compiling 32bit, unsigned int
    64 bit wide when compiling 64bit, unsigned long long
    ! size of types varies, use sizeof() to test
    ~ no different from using an unsigned int directly
    ~ just for clarification of intent, i.e. loops, arrays, etc.
    ~ many standard headers use size_t when numbers cant be neg.
    example: 
      size_t size = sizeof(float);
#
#
|NULL|null|pointer|
    pointer of value 0, defined in most standard header files
    ! trying to acces a null pointer causes a crash
    ~ NULL is (void*)0
    example: 
     \#ifndef NULL
      \#define NULL (void*)0
     \#endif
     int* ptr = NULL;
     if (ptr \!= NULL) { free(ptr); }
     if (ptr)  { printf("ptr = not null"); }
     if (\!ptr) { printf("ptr = null"); }
#

operators:


#
|pointer|address|sizeof|
|basics|operator|operators|size|
|*|&|
  *:      pointer operator, indicates a type is 
          pointer-type, or dereferences a pointer
          which lets you access the variable pointed to
  &:      gets the address of a variable, aka. the pointer
          to that variable
  sizeof: gets compiled to the size of the given type in bytes

  example:
    int  a = 0;
    int* a_ptr = &a;  // a_ptr holds the address of a

    *a_ptr = 1;  // dereferencig a_ptr to access a 
    printf("a: %d", a);
    -> 1

    // @NOTE: the size of variables depend on the os
    //        32bit os's might have different size 
    //        variables than 64bit os's
    printf("size of char: %d", sizeof(char));
    printf("size of short: %d", sizeof(short));
    printf("size of int: %d", sizeof(int));
    printf("size of long int: %d", sizeof(long int));
    -> size of char: 1
    -> size of short: 2
    -> size of int: 4
    -> size of long int: 8
    printf("size of float: %d", sizeof(float));
    printf("size of double: %d", sizeof(double));
    ->size of float: 4
    ->size of double: 8
    // @NOTE: sizeof returns bytes, aka.
    //        char: 1 byte,  8  bits
    //        int:  4 bytes, 64 bites
    //        etc.
#
|basics|arithmetic_operators|operator|operators|
|+|-|/|*|%|++|--|
|add|addtition|sub|subtract|div|divide|mul|multiply|mod|modulo|
  basic mathematic/arithmetic operators
  +:  addition
  -:  subtraction
  /:  division
  *:  multiplication
  %:  modulo, remainder of integer division
  ++: add 1, same as x = x+1
  --: sub 1, same as x = x+-1

  ~ integer divisons dont produce and get rounded
  ~ ++/-- can be applied before or after the variable
  $~$  before in-/decrements variable and then executes other logic$$
  $~$  after executes logic and then in-/decrements, see example$$

  example:
    a = 1 + 1;       // a = 2
    a = 1 - 1;       // a = 0
    a = 2.0f / 1.0f; // a = 0.5f
    a = 2 * 2;       // a = 4
    a = 5 % 2;       // a = 1, 5 / 2 = 2 remaineder 1
    a = 1;
    a++;             // a = 2
    a--;             // a = 1

    int arr[3] = { 0, 1, 2 }; // arr[0] == 0, arr[1] == 1, etc.
    int i = 0;
    int a = arr[i++];
    printf("a: %d, i: %d\n", a, i);
    -> a: 0, i: 1 // accessed arr with i = 0, then incremented
    i = 0;
    int a = arr[++i];
    printf("a: %d, i: %d\n", a, i);
    -> a: 1, i: 1 // incremented i to i == 1, then accessed arr
#
|basics|operator|boolean|
|comparison|realtional_operator|realtional_operators|
|equal|not_equal|less|less_than_or_equal|greater|greater_than_or_equal|
|==|!=|<|<=|>|>=|
|logical_operator|logical_operators|
|and|or|invert|not|
|&&|!|
  
  all the below operators perform some action
  but dont change values on their own, but can be
  used to set values, explicitly
  they get evaluated as a boolen value true/false
  and can therefore be used to, set values, for 
  if, for, while, etc. statements
  ~ using parenthesis any of these statements can 
  $~$  directly be used like a boolean value$$

  $GREEN$relational operators$$:
    a == b -> equal 
    a \!= b -> not equal
    a <  b -> less than
    a <= b -> less than or equal
    a >  b -> greater than
    a >= b -> greater than or equal
    
  $GREEN$logical operators$$:
    a && b -> logical and
    a \|\| b -> logical or
    \!a     -> logical not
              inverts any boolean value
              be that a variable or a 
              statement that gets evaluated
              as a boolean, sucha as the ones above
  
  example:
    // -- relational operators --
    int a = 5;
    int b = 8;
    bool c;
    c = a == b; // false
    c = a == a; // true
    c = a \!= b; // true
    c = a \!= a; // false
    c = a <  b; // true
    c = a <= b; // false
    c = a >  b; // false
    c = a >= b; // true

    // -- logical operators --
    bool a = true;
    bool b = false;
    c = a && b; // false
    c = c && b; // true
    c = c \|\| b; // false
    c = a \|\| b; // true

    // -- combinig --
    bool a = (1 > 0) \|\| (0 > -1); // true
    bool b = false;
    bool c = (a \|\| b) && (a \!= b \|\| b == false);
    if ( (a \|\| b) && (a \!= b \|\| b == false) ) {}
    for (into = 0; (a \|\| b) && (a \!= b \|\| b == false); ++i) {}
    while ( (a \|\| b) && (a \!= b \|\| b == false) ) {}
    c = (a \|\| b) && (a \!= b \|\| b == false) ? true : (!a == false && b) ? true : false;

    // -- logical not \! --
    bool a = true;
    bool b = \!a;    // b is now false
    a = \!a;         // a is now false
    a = \!a;         // a is now true
    int c = 0;
    c = \!c;         // c is now 1
    
    if (\!a) 
    { printf("a didnt change value, but was evaluated as false"); }
    
    a = true; b = true;
    if (\!(a && b)) { printf("wont execute"); }

    bool func() { return true; }

    if ( func()) { printf("func()"); }
    if (\!func()) { printf("!func()"); }
    
    // a is true so this evals. as \!(true) -> false
    bool d = \!(a \? true : false); 

    -> func()
#
|operator|bitwise_operator|basics|
|bit_shift|shift|bitwise_or|or|bitwise_and|and|
|<<|>>|&|
  bit shift
    <<: left sides bits are moved left by number on right side
    >>: left sides bits are moved right by number on right side
  bit wise or, and & not
    &: binary and
    \|: binary or
    ^: binary xor
    \~: binary not

  example:
    unsigned int a = 0b001; // a is now 001
    a >> 1;                 // a is now 010
    a << 1;                 // a is now 001
    
    unsigned int a = 0b0001;
    unsigned int b = 0b1000;
    unsigned int c = a \| b; // 1001
    unsigned int d = c & a; // 0001
    unsigned int e = c ^ a; // 1000
    unsigned int f = ~c;    // 0111

?< https://www.tutorialspoint.com/cprogramming/c_operators.htm >?
#
|operator|bitwise_operator|basics|
|assign|assignment|assignment_operators|
|add|addtition|sub|subtract|div|divide|mul|multiply|mod|modulo|
|bit_shift|shift|bitwise_or|or|bitwise_and|and|
|+=|-=|*=|/=|%=|<<=|>>=|&=|\|=|^=|

  =:   a = b;   a's value is now b's value
  
  $GREEN$arithmetic operators, see $|$\|arithmetic_operators\|$$:
  +=:  a += b;  is equal to a = a + b
  -=:  a -= b;  is equal to a = a - b
  *=:  a *= b;  is equal to a = a * b
  /=:  a /= b;  is equal to a = a / b
  %=:  a %= b;  is equal to a = a % b
  
  $GREEN$bitwise operators, see $|$\|bitwise_operator\|$$:
  <<=: a <<= b; is equal to a = a << b
  >>=: a >>= b; is equal to a = a >> b
  &=:  a &= b;  is equal to a = a & b
  \|=:  a \|= b;  is equal to a = a \| b
  ^=:  a ^= b;  is equal to a = a ^ b

  example: 
    int a = 10; // assign 10 to a 
    a += 10;    // a: 20
    a -= 10;    // a: 10
    a *= 10;    // a: 100
    a /= 10;    // a: 10
    a %= 4;     // a: 2, 10 / 4 = 2, remainder 2
  
    // also work on non-literal values:
    int b = 5;
    a += b;
    a += func();

    a = 1;
    a <<= 1;    // a: 0b0010
    b = a;
    b >>= 1;    // b: 0b0001
    int c = a;  
    c \|= b;     // c: 0b0011
    c &= a;     // c: 0b0010
    c = a \| b;  // c: 0b0011 
    c ^= a;     // c: 0b0001
#

misc:

#
|bit_flag|flag|bitwise_operator|basics|
  set and check certain bits in a number
  make number with bit a set

  see $|$\|bitwise_operator\|$$ for explanation
  of <<, >>, &, \| operators

  example:
  
  make a number with specific bit set:
    1 << 0 0001
    1 << 1 0010
    1 << 2 0100
    1 << 3 1000
    aka. 1<<a == 2^a, 1, 2, 4, 8, ...
  combine numbers with specific bits set:
    unsigned int a = 1 << 0;  // 0001 
    unsigned int b = 1 << 3;  // 1000
    unsigned int c = a \| b;   // 1001
  check if bit is set:
    unsigned int a = 1 << 0;  // 0001 
    unsigned int b = 1 << 3;  // 1000   
    unsigned int c = a \| b;   // 1001
    bool d = a & b;           // false
    bool e = a & c;           // true, 0001 in common
  set specific bit 0:
    unsigned int a = 1 << 0 \| 1 << 3;  // 1001
    a = a &= \~(1 << 0);                // 1000

  macros:
    \#define FLAG(a)            (1 << (a))
    \#define HAS_FLAG(a, b)     ((a) & (b))
    \#define FLAG_COMBINE(a, b) ((a) \| (b))
    \#define REMOVE_FLAG(a, b)  ((a) &= ~(b))

  enums:
    enum example_flag
    {
      HAS_A = FLAG(0),
      HAS_B = FLAG(1),
      HAS_C = FLAG(2)
    };
    example_flag a = HAS_A \| HAS_B \| HAS_C;
    REMOVE_FLAG(a, HAS_B);
    if (HAS_FLAG(a, HAS_A)) { printf("has a");}
    if (HAS_FLAG(a, HAS_B)) { printf("has b");}
    if (HAS_FLAG(a, HAS_C)) { printf("has c");}
      -> has a
      -> has b
#

macros:

#
|inline|function|
|always_inline|__forceinline|
  inlining is a way to define a function where
  when called, the compiler doesnt tell the cpu
  to jump to the location in memory where the 
  instructions for that function are, but rather
  simply always puts all contents of the function 
  directly where it is called
  inline functions forego having to load a part of
  the programs instructions, that could be anywhere 
  in the programs machine code, which means the cache
  of the cpu might have to be completely overwritten
  rather than loading the next instructions which are
  automatically loaded in the cache, this is slow. 
  so instead of jumping between memory, just putting 
  smaller functions directly where they are called is 
  faster, but increases the overall size of the executable.

  ~ in short if you have small functions you call a lot
  $~$  it might be worth inlining them$$

  ~ inlining is actually just forcing it, the compiler 
  $~$  already inlines to optimize$$

  ~ different compilers have different ways to inline
  $~$  __forceinline is used by msvc, microsofts c/c++ compiler
    static inline __atribute  ((always_inline)) by most others$$


  example:
    in file.h
    \#if defined(_MSC_VER)
      \#define INLINE __forceinline
    \#else
      \#define INLINE static inline __attribute((always_inline))
    \#endif
  
    INLINE int inline_func(int a)
    {
      int rtn = a + 20;
      if (rtn > 50) { rtn -= 12; }
      return rtn;
    }

    in file.c
    \#include "file.h"
    void func()
    {
      int a = inline_func();
    }

  $GREEN$difference$$:
    simplified visualization of difference 
    between normal/inline functions

    INLINE int inline_add(int a, int b) { return a + b; }
    
    int normal_add(int a, int b) { return a + b; } 
    void func()
    {
      int a0 = normal_add(1, 2);
      int a1 = inline_add(1, 2);
    }

    roughly what the compiler does:
    void func()
    {
      int a0 = normal_add(1, 2);
      int a1 = a + b;
    }

#
|stringify|
|operator|preprocessor|macro|basics|
|to_string|\#|
  and \\# to macro arg to stringify it
  example:
    \#define TO_STR(arg)  (\\#arg)
    int var = 0;
    printf("%s: %d\n", TO_STR(var), var);
      -> var: 0
    \#define P_INT(a) printf("%s: %d\n", \\#a, a)
    P_INT(var);
      -> var: 0
#
|token_pasting|
|operator|preprocessor|macro|basics|
|combine_macros|token|\#\#|
  using the \\#\\# operator in macros
  you can expand an argument or macro and
  combine it with other text
  ~ using this operator prevents tokens 
  $~$  that are macros to expand $$
  $~$  making a pasting macro prevents this $$

  example:
    \#define TOKEN_PASTING(a, b)  a\\#\\#b
    TOKEN_PASTING(hello, world);
    -> helloworld
    
    \#define ARRAY(type, name, len) \
        type name[len];             \
        int name\\#\\#_len = len;
    ARRAY(int, arr, 10);
    -> int arr[10];
    -> int arr_len = 10;

    \#define PASTE(a, b, c, d) a\\#\\#b\\#\\#c\\#\\#d
    int PASTE(start, _mid, dle, _end) = 10;
    -> int start_middle_end = 10;

    // because \\#\\# doesnt expand macros
    \#define _I    int
    \#define PASTE(a, b)      a\\#\\#b
    \#define PASTE_2(a, b)    PASTE(a, b)
    \#define PASTE_3(a, b, c) PASTE_2(PASTE_2(a, b), c)
    
    int PASTE_3(start, _middle_, end) = 10;
    printf("%s\n", \\#PASTE_3(start, _middle_, end));
    -> start_middle_end
    
    int PASTE_3(_I, _middle_, end) = 10;
    printf("%s\n", \\#PASTE_3(_I, _middle_, end));
    ->int_middle_end
    // would be _I_middle_end otherwise
#
|__FILE__|__LINE__|__DATE__|__TIME__|
|__func__|__FUNCTION__|__STDC__|__STDC_HOSTED__|__STDC_VERSION__|
|file|line|date|time|function|function_name|c-version|
|preprocessor|macro|basics|
  
  __FILE__:         is a marco that gets set to the 
                    current file name during compilation
  
  __LINE__:         is a marco that gets set to the 
                    current line during compilation

  __DATE__:         is a mqacro that gets set to the date 
                    on which the source was compiled to .o
                    format is MM DD YYYY

  __TIME__:         is a macro that gets set to the time
                    at which the source was compiled to .o

  __func__:         in C99+ this expands to the current
                    functions name

  __FUNCTION__:     expands to current function name
                    only available in some compilers
                    use __func__ instead is using C99+

  __STDC__:         if set to 1 this means the compiler
                    conforms to ISO C standards
                    this should usually be the case
  
  __STDC_HOSTED__:  idk, but should generally be 1 

  __STDC_VERSION__: gets set to the current c version
                    i.e. C89, C99, etc., 
                    see \|c-version\| for more info

  example:
    \#define PRINT_LOCATION() printf("file: \"%s\", line: %d\n", __FILE__, __LINE__)
    file_a.c:
    [83] PRINT_LOCATION();
      -> file: "file_a.c", line: 83
    file_b.c:
    [10] PRINT_LOCATION();
      -> file: "file_b.c", line: 10
    
    printf("compiled on: %s", __DATE__);
    printf("compiled at: %s", __TIME__);
    -> compiled on: Mar 24 2023
    -> comnpiled at: 21:04:56
    
    printf("__func__: %s", __func__);
    printf("__FUNCTION__: %s", __FUNCTION__);
    -> __func__: func_name
    -> __FUNCTION__: func_name

    printf("__STDC__: %d", __STDC__);
    printf("__STDC_HOSTED__: %d", __STDC_HOSTED__);
    printf("__STDC_VERSION__: %d", __STDC_VERSION__);
    -> __STDC__: 1
    -> __STDC_HOSTED__: 1 
    -> __STDC_VERSION__: 199901
#
|compiler|
|__GNUC__|__MINGW32__|__MINGW64__|__clang__|_MSC_VER|__EMSCRIPTEN__|
|c++|__cplusplus|
|macro|preprocessor|basics|
  compiler defining macros
  ~ see \|c-version\| for checking/setting the c version
  ~ when __MINGW32/64__ is def. __GNUC__ should also be

  __GNUC__:       gcc compiler
  __MINGW32__:    32 bit version of mingw
  __MINGW64__:    64 bit version of mingw
  __clang__:      clang compiler
  _MSC_VER:       msvc, microsofts c/c++ compiler
  __EMSCRIPTEN__: llvm to js or web-asm compiler

  __cplusplus: actually compiling c++ code
               c++ compilers can compile c
               but you need to define extern "C"
  __OBJC__:    defined when compiling using 
               objective-c compiler
  example:
    in .h file
    \#ifdef __cplusplus
    extern "C" {
    \#endif
    void func();
    \#ifdef __cplusplus
    } // extern "C"
    \#endif

?< https://dev.to/tenry/predefined-c-c-macros-43id >?
#
|_WIN32|_WIN64|__linux|__linux__|__APPLE__|__ANDROID__|
|windows|linux|apple|macos|ios|android|operating_system|os|
|macro|preprocessor|basics|
  os specific macros

  _WIN32:      is defined when on a windows 32/64 bit operating system
  _WIN64:      is defined when on a windows 64 bit operating system
  __linux
  __linux__:   is defined when on a linux operating system
  __APPLE__:   is defined when on a apple/macos/ios operating system
  __ANDROID__: is defined when on a android operating system

  example:
    \#ifdef _WIN32
      printf("running on windows");
    \#elif  defined(__linux__)
      printf("running on linux");
    \#endid

?< https://dev.to/tenry/predefined-c-c-macros-43id >?
#
|__VA_ARGS__|
|variadic_arguments|variadic|preprocessor|macro|basics|
  the macro __VA_ARGS__ is used when creating variadic macros
  which means macros that variable amount of arguments
  it is the arguments themself, and should only directly be
  passed to a variadic function

  example:
    \#define PF(...)    printf(__VA_ARGS__)
    PF("hello\n");
    PF("int: %d\n", 12);
    PF("%s %s %s\n" "multiple", "args", "given");
    -> hello
    -> int: 12
    -> multiple args given
#
|defined|
|preprocessor|macro|basics|
  turns a macro into a suitable condition for \\#if, \\#elif

  example:
    \#define A
    \#if    defined(A)
      printf("A");
    \#elif  defined(B)
      printf("B");
    \#elif !defined(B)
      printf("not B");
    \#endif
    -> A
    -> not B
#
|define|
|preprocessor|macro|basics|
    the define preprocessor registeres 
    a piece of code under a name
    alternatively a macro can also just 
    be defined to check if its defined using \\#ifdef
    ~ use '\' to make multiline macros, no whitespace after '\'
    ~ wrapping args in parenthesis makes it safer 
    example:
      \#define HELLO
      \#define NAME   "karl"
      \#define NUMBER 34 * 67
      \#define ADD(a, b) ((a) + (b))
      \#define WARNING()      \
        printf("[!!!]");      \
        printf(" warning\n")

      printf("%s\n", NAME);
      printf("%d\n", NUMBER);
      printf("%d\n", ADD(30, 70));
      WARNING();
      \#ifdef HELLO
        printf("hello is defined\n");
      \#endif
        -> karl
        -> 2278 
        -> 100
        -> [!!!] warning
        -> hello is defined
#
|undef|
|undefine|preprocessor|macro|basics|
  the undef preprocessor undefines a previously defined macro
  example:
    \#define A
    \#ifdef A
      printf("A");
    \#endif
    \#undef A
    \#ifdef A
      printf("A again");
    \#endif
    -> A
#
|if|
|endif|preprocessor|macro|basics|
  check a condition at compile time and include a piece of code or not
  ! has to be terminated with one of \#endif, \#else or \#elif
  
  example:
    \#if 0 == 0
    printf("0 == 0");
    \#endif
    \#if 0 == 1
    printf("0 == 1");
    \#endif
      -> 0 == 0
#
|else|
|endif|preprocessor|macro|basics|
  used with the \\#if, \\#elif, \\#ifdef preprocessors
  
  example:
    \#if 0 == 0
    printf("0 == 0");
    \#else
    printf("0 != 0");
    \#endif
      -> 0 == 0
#
|elif|
|else|endif|preprocessor|macro|basics|
  used with the \\#if, \\#else, \\#ifdef preprocessors

  example:
    \#if 0 == 0
    printf("0 == 0");
    \#elif 0 == 1
    printf("0 == 1");
    \#endif
      -> 0 == 0
#
|ifdef|
|endif|preprocessor|macro|basics|
  the ifdef preprocessor ex/includes a part of code
  depending on if the given macro is defined

  example:
    \#ifdef A
      printf("A0");
    \#endif
    \#define A
    \#ifdef A
      printf("A1");
    \#endif
    -> A1
#
|ifndef|
|endif|preprocessor|macro|basics|
  the ifndef preprocessor ex/includes a part of code
  depending on if the given macro is not defined

  example:
    \#ifndef A
      printf("A0");
    \#endif
    \#define A
    \#ifndef A
      printf("A1");
    \#endif
    -> A0
#
|error|
|print|preprocessor|macro|basics|
  the error preprocessor error prints an error to the stderr

  example:
    \#error "this is an error"

    \#undef MACRO
    \#ifndef MACRO
      \#error "MACRO isnt defined"
    \#endif
     
     -> this is an error
     -> MACRO isnt defined
#
|pragma|
|preprocessor|macro|basics|
|gcc|ignore_warning|
  the pragma preprocessor issues commands to the compiler,
  therefore the commands may vary from compiler to compiler

  example:
    // this makes gcc ignore the specified in "-W..."
    // until diagnostic pop is called
    // in this example were including a header that uses 
    // pragmas not used by gcc, so we ignore the error
    // messages this would normally generate
    // at least when comopiling with "-Wall", 
    // aka. all warnings
    \#pragma GCC diagnostic push
    \#pragma GCC diagnostic ignored "-Wunknown-pragmas"
    \#include "header_with_non_gcc_pragmas.h"
    \#pragma GCC diagnostic pop
#


flow control:

#
|if|
|flow_control|basics|
  execute a piece of code based on a condition

  example:
    if (0 == 0)  { printf("0 == 0"); }
    if (true)    { printf("true"); }
    if (false)   { printf("false"); }
    bool boolean = true;
    if (boolean) { printf("boolean"); }
    boolean = false;
    if (boolean) { printf("boolean"); }
      -> 0 == 0
      -> true
      -> boolean
#
|else|else_if|
|flow_control|basics|
  after a if or else if statement this executes
  a block of code if the previous statement didnt
  else if executes the block of code under those 
  circumstances as well as checking the given condition

  example:
    if (0 == 0) { printf("0 if");   }
    else        { printf("0 else"); }
    
    if (0 == 1) { printf("1 if");   }
    else        { printf("1 else"); }

    if (0 == 1)    { printf("2 if");      }
    else if (0==0) { printf("2 else if"); }
    else           { printf("2 else");    }
    
    int c = 2;
    if (c == 0)      { printf("c == 0"); }
    else if (c == 1) { printf("c == 1"); }
    else if (c == 2) { printf("c == 2"); }
    else if (c == 3) { printf("c == 3"); }
    else             { printf("c == ?"); }
    -> 0 if
    -> 1 else
    -> 2 else if
    -> c == 2
#
|?|operator|
|flow_control|basics|
  single line statement evaluating to a value
  that works like a if / if else / else chain
  
  $GREEN$structure$$:
    condition ? if true : if false
    can be chained
    condition_a ? if true : condition_b ? if true : ...

  example:
    // eval to bool
    bool a = 0 == 0 ? true : false; // 0 is 0 so a is true
    if (a ? false : true) {}
    
    // eval to other value
    int num  = 3;
    int num2 = num == 0 ? 0 : num == 1 ? 1 : 
               num == 2 ? 2 : num == 3 : 3;    // num2 is also 3

    float speed = 10.0f;
    pow(2, speed > 8.0f ? 4 : 6);
#
|while|while_loop|
|flow_control|loop|basics|
|break|continue|
  repeatedly executes a block of code
  while the given condition is true
  ~ use the break command to exit the loop
  ~ use continue to skip the rest of the current loops run
  ~ and continue at the start of the lopo
  ! if the condition never turns false
  ! the program will be stuck in the loop

  example:
    // for loop using while loop
    int count = 10;
    while (count <= 0) { printf("%d, ", count); count--; }
    -> 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0,

    // search string text for '%'
    bool found = false;
    int  pos   = 0;
    while (found = false && pos < text_length)
    { if (text[pos] == '%') { found = true; } pos++; }
    if (found) { printf("found %% at %d\n", pos); }
    -> found % at XXX

    // infinite loop, with break
    int end = 222;
    int pos = 0;
    while (true)
    { 
      if (pos >= end) { break;} 
      pos++;
    }
    printf("pos: %d\n", pos);
    -> pos: 221

#
|do_while|do|while|do_while_loop|
|flow_control|basics|
  same as while loop, only that this loop executes the block
  once before checking the condition, assuring it always gets 
  executed least once
  see \|while\| for more explanation
  ~ break exits out of the loop
  ~ continue jumps to the start of the loop

  example:
    int a = 0;
    do
    {
      a++;
    }
    while (false);
    printf("a: %d\n", a);
    -> a: 1
#
|for|for_loop|
|flow_control|loop|basics|
  the for loop executes a block of code 
  as long as the middle condition is true
  it also initializes a local variable
  and allows you to execute a line of code 
  at the end of each loop
  this loop cant do anything the while loop cant do
  but its purpose is often easier to understand
  thanks to the for loops's structure
  ~ its common to call the for loops variable i
  ~ for iterator, j, k, follow if you have a nested loop
  ~ break exits out of the loop
  ~ continue jumps to the start of the loop

  $GREEN$structure$$:
    for (INITIALIZE_VAR; CONDITION; EXECUTES_AT_END_OF_LOOP)
    { BLOCK_OF_CODE }
    ~ equivalent to:
    INITIALIZE_VAR
    while (CONDITION)
    {
      BLOCK_OF_CODE
      EXECUTES_AT_END_OF_LOOP
    }
  example: 
    for (int i = 0; i < 10; ++i)
    { printf("%d, ", i); }
    -> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
    
    int arr[3] = { 4, 5, 6 };
    int arr_len = 3;
    for (int i = 0; i < arr_len; ++i)
    { printf("%d, ", arr[i]); }
    -> 4, 5, 6,
#
|switch|case|default|
|flow_control|loop|basics|
  the switch statement checks a input variable 
  agaist multiple cases and executes the code 
  if cases are met by the variable

  ~ break exits out of the switch statement
  ~ default case must be last, is optional and
  $~$  only gets executed if no other case was $$
  ~ without a break the statement falls through to 
  $~$  the one below$$

  example: 
    int c = 1;
    
    switch (c)
    {
      case 0  :
        printf("c is 0");
        break;
      case 1  :
      case 11 :
        printf("c has 1");
      case 2  :
      case 22 :
        printf("c has 2");
        break;

      default :
      printf("none of the above");
    }
    -> c has 1
#

compiler stuff, should prob get its own sheet:

#
|c-version|c|version|c89|c99|c11|c18|compiler|macro|
    c was originally made in 1972 by Dennis Ritchie, 
    so theres been a lot of versions since then
    if you want to check which version you are
    currently compiling in use the macros shown below

    setting a specific c version to use 
    depends on the compiler see below

    example:
      // print version
      if (__STDC_VERSION__ >=  201710L)       
      { printf("-- using c18 --\n"); }            
      else if (__STDC_VERSION__ >= 201112L)   
      { printf("-- using c11 --\n"); }            
      else if (__STDC_VERSION__ >= 199901L)   
      { printf("-- using c99 --\n"); }            
      else                                    
      { printf("-- using c89/c90 --\n"); }
      
      // set version in compiler
      // in makefile / directly in terminal
      
      gcc -std=c90  // c89 / c90
      gcc -std=c99  // c99
      gcc -std=c11  // c11
      gcc -std=c17  // c17 / 18
      // c89 and c90 is the same version
      // in gcc c99 implemnts corrertions of the early 2000s versions
      // in gcc c11 and c17 only differ in the value '__STDC_VERSION__'

      clang -std=c89 -std=c90   // c89 / c90
      clang -std=gnu89          // c89 with gnu extensins
      clang -std=c99
      clang -std=gnu99          // c99 with gnu extensins
      clang -std=c11
      clang -std=gnu11          // c11 with gnu extensins
      clang -std=c17
      clang -std=gnu17          // c17 with gnu extensins

      // msvc is a windows specific compiler made by
      // microsoft for Visial Studio, etc.
      // could not find older versions supported by msvc
      // use '/' or '-' to start a command  
      msvc /std:c11 -std:c11
      msvc /std:c17 -std:c17

      ?< gcc: https://gcc.gnu.org/onlinedocs/gcc/Standards.html >?
      ?< clang: https://clang.llvm.org/docs/CommandGuide/clang.html >?
      ?< msvc: https://docs.microsoft.com/en-us/cpp/build/reference/compiler-options-listed-by-category?view=msvc-170 >?
      ?<c: https://en.wikipedia.org/wiki/C_(programming_language) >?           
#

entry-point:

#
|entry_point|main|basics|
|command_line|command_line_arguments|arguments|
|EXIT_SUCCESS|EXIT_FAILURE|
  the entry point function is the function that gets 
  automatically executed at the start of the program
  so it is where all your logic should start
  the returned int indicates if the program ran 
  successfully or not, uses the $G$macros$$
  the entry point function is always called 'main'
  it can be type int main(), int main(void) or $$
  int main(int, char**) / int main(int, char* argv[]) $$
  both are the same, an array of char* / string

  $G$macros$$:
    EXIT_SUCCESS: 0,     can be returned in main() 
    EXIT_FAILURE: non 0, can be returned in main() 

  example:
    int main()
    {
      ...
      return EXIT_SUCCESS;
    }
    
    // if invoked in terminal, i.e >app arg1 arg2 arg3
    int main(int argc, char** argv)
    {
      // standard names
      // argc: argument count
      // argv: argumnet value

      // print all command line args
      for (int i = 0; i < argc; ++i)
      {
        printf("argument[%d]: %s\n", argc, argv[i]);
      }
      -> arg1
      -> arg2
      -> arg3

      return 0; // same as EXIT_SUCCESS
    }

    // exit failure if file not found
    int main()
    {
      FILE* f = fopen("file.txt", "r");
      if (f == NULL)
      {
        return EXIT_FAILURE;
      }
      
      ...
  
      return EXIT_SUCCESS;
    }

#

